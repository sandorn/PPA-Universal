# PPA 项目代码审查清单

> **使用说明**：
>
> - 本清单用于代码提交前的自检和代码审查
> - 运行 `tools/code-review-scan.ps1` 进行自动化检查
> - 定期审查（建议每月）确保代码质量

## 快速开始

### 运行自动化扫描

```powershell
# 检查所有规则
.\tools\code-review-scan.ps1 -All

# 检查特定类别
.\tools\code-review-scan.ps1 -Application
.\tools\code-review-scan.ps1 -Logging
.\tools\code-review-scan.ps1 -ComLifecycle
```

### 手动检查清单

在提交代码前，快速检查以下关键项：

- [ ] 是否使用了 `ApplicationHelper` 获取 Application？
- [ ] 是否使用了 `ILogger` 而不是 `Profiler.LogMessage`？
- [ ] 循环中的 COM 对象是否在适当的时候释放？
- [ ] 是否支持 Undo 操作？
- [ ] 是否提供了用户反馈（Toast）？

---

## 一、Application 调用规范

### 1.1 NetOffice Application 获取

- [ ] **禁止直接访问 `Globals.ThisAddIn.Application`**

  - ❌ 错误：`var app = Globals.ThisAddIn.Application;`
  - ✅ 正确：`var app = ApplicationHelper.GetNetOfficeApplication();`

- [ ] **使用 `ApplicationHelper.EnsureValidNetApplication` 确保有效性**

  - ✅ 正确：在方法开始时调用 `netApp = ApplicationHelper.EnsureValidNetApplication(netApp);`
  - ✅ 正确：在需要刷新 Application 时调用

- [ ] **禁止缓存 Application 对象**

  - ❌ 错误：在类字段中缓存 `private NETOP.Application _cachedApp;`
  - ✅ 正确：每次需要时通过 `ApplicationHelper` 获取

- [ ] **Application 刷新策略**
  - ✅ 正确：在 `TryRefreshContext` 方法中统一处理 Application 刷新
  - ✅ 正确：当 `ActiveWindow` 为 null 时，调用 `ApplicationHelper.EnsureValidNetApplication`

### 1.2 Native COM Application 访问

- [ ] **必须通过 `ApplicationHelper.GetNativeComApplication` 获取**

  - ❌ 错误：直接访问 `netApp.UnderlyingObject`
  - ✅ 正确：`var nativeApp = ApplicationHelper.GetNativeComApplication(netApp);`

- [ ] **必须使用 `NativeComGuard` 或同等封装**

  - ✅ 正确：所有 native COM 调用必须记录调用方信息
  - ✅ 正确：确保 native COM 对象在使用后释放

- [ ] **禁止在业务逻辑中直接使用 native COM**
  - ❌ 错误：在格式化方法中直接使用 `MSOP.Application`
  - ✅ 正确：优先使用 NetOffice，仅在必要时使用 native COM

### 1.3 Application 对象比较

- [ ] **禁止直接使用 `==` 比较 NetOffice Application 对象**

  - ❌ 错误：`if (app1 == app2)`
  - ✅ 正确：使用 `ReferenceEquals` 或通过 `ApplicationHelper` 比较

- [ ] **使用 `ApplicationHelper` 提供的比较方法**
  - ✅ 正确：通过 `ApplicationHelper` 统一管理 Application 对象比较

## 二、日志记录规范

### 2.1 日志接口使用

- [ ] **统一使用 `ILogger` 接口**

  - ❌ 错误：`Profiler.LogMessage("...");`
  - ✅ 正确：`_logger.LogInformation("...");`

- [ ] **禁止新建 `Profiler.LogMessage` 调用**

  - ✅ 正确：所有新代码必须使用 `ILogger`
  - ✅ 正确：通过依赖注入获取 `ILogger` 实例

- [ ] **日志级别使用**
  - ✅ `LogDebug`：详细的调试信息，仅在开发时启用
  - ✅ `LogInformation`：一般信息，记录关键操作流程
  - ✅ `LogWarning`：警告信息，不影响功能但需要注意
  - ✅ `LogError`：错误信息，包含异常对象

### 2.2 日志内容规范

- [ ] **包含上下文信息**

  - ✅ 正确：`_logger.LogInformation($"FormatTables 启动，netApp类型={netApp?.GetType().Name}");`
  - ❌ 错误：`_logger.LogInformation("启动");`

- [ ] **避免泄露用户隐私**

  - ❌ 错误：记录用户文件路径、用户名等敏感信息
  - ✅ 正确：记录操作类型、对象数量等非敏感信息

- [ ] **异常日志必须包含异常对象**
  - ✅ 正确：`_logger.LogError($"处理失败: {ex.Message}", ex);`
  - ❌ 错误：`_logger.LogError($"处理失败: {ex.Message}");`

### 2.3 调用者信息

- [ ] **使用 `[CallerMemberName]` 和 `[CallerFilePath]`**

  - ✅ 正确：`ILogger` 接口已包含这些参数，自动传递调用者信息
  - ✅ 正确：日志输出应显示实际调用类和方法，而不是适配器类

- [ ] **避免显示适配器类名**
  - ❌ 错误：日志显示 `ProfilerLoggerAdapter.Log`
  - ✅ 正确：日志显示 `CommandExecutor.ExecuteMso`

## 三、COM 对象生命周期管理

### 3.1 基本规则

- [ ] **所有 NetOffice COM 对象必须实现 `IDisposable`**

  - ✅ 正确：`NETOP.Shape`、`NETOP.Slide`、`NETOP.Table` 等都实现了 `IDisposable`

- [ ] **使用 `using` 语句释放 COM 对象**

  - ✅ 正确：
    ```csharp
    using(var slide = AdapterUtils.UnwrapSlide(abstractSlide))
    {
        // 使用 slide
    }
    ```

- [ ] **禁止在循环外持有大量 COM 对象**
  - ❌ 错误：在循环中收集所有对象到列表，循环结束后才释放
  - ✅ 正确：在循环中立即处理并释放，或使用 `DisposeAll()` 统一释放

### 3.2 循环中的 COM 对象

- [ ] **集合对象必须使用 `using` 释放**

  - ✅ 正确：
    ```csharp
    using(var shapes = slide.Shapes)
    {
        foreach(NETOP.Shape shape in shapes)
        {
            // 处理
        }
    }
    ```

- [ ] **循环中的单个对象**

  - ✅ 如果对象不需要在循环外使用，使用 `using` 立即释放：
    ```csharp
    foreach(NETOP.Shape shape in shapes)
    {
        using(shape)
        {
            ProcessShape(shape);
        }
    }
    ```

- [ ] **需要收集后批量处理的情况**
  - ✅ 正确：使用 `DisposeAll()` 扩展方法统一释放：
    ```csharp
    List<NETOP.Shape> shapesToProcess = new List<NETOP.Shape>();
    try
    {
        foreach(var shape in shapes)
        {
            shapesToProcess.Add(shape);
        }
        // 批量处理
    }
    finally
    {
        shapesToProcess.DisposeAll();
    }
    ```

### 3.3 表格和单元格对象

- [ ] **Row 和 Cell 对象必须释放**

  - ❌ 错误：
    ```csharp
    for(int r = 1; r <= rows; r++)
    {
        var row = tbl.Rows[r];  // 未释放
        for(int c = 1; c <= cols; c++)
        {
            var cell = row.Cells[c];  // 未释放
            // 使用 cell
        }
    }
    ```

- [ ] **推荐：立即处理模式**

  - ✅ 正确：
    ```csharp
    for(int r = 1; r <= rows; r++)
    {
        using(var row = tbl.Rows[r])
        {
            for(int c = 1; c <= cols; c++)
            {
                using(var cell = row.Cells[c])
                {
                    ProcessCell(cell);
                }
            }
        }
    }
    ```

- [ ] **如果必须批量处理**
  - ✅ 正确：在批量处理结束后统一释放：
    ```csharp
    var cells = new List<NETOP.Cell>();
    // 收集 cells
    try
    {
        // 批量处理
    }
    finally
    {
        cells.DisposeAll();
    }
    ```

### 3.4 ShapeRange 和 Selection

- [ ] **ShapeRange 必须使用 `using` 释放**

  - ✅ 正确：
    ```csharp
    using(var range = selection.ShapeRange)
    {
        for(int i = 1; i <= range.Count; i++)
        {
            using(var shape = range[i])
            {
                ProcessShape(shape);
            }
        }
    }
    ```

- [ ] **注意：如果 Shape 需要添加到列表**
  - ⚠️ 注意：不能立即释放，需要在列表使用完毕后统一释放
  - ✅ 正确：在 `ProcessTables` 等方法中，处理完每个对象后立即释放

### 3.5 异常处理中的释放

- [ ] **使用 `try-finally` 确保释放**

  - ✅ 正确：
    ```csharp
    List<NETOP.Shape> shapes = new List<NETOP.Shape>();
    try
    {
        // 处理 shapes
    }
    finally
    {
        shapes.DisposeAll();
    }
    ```

- [ ] **避免在 catch 块中重复释放**
  - ❌ 错误：在 catch 和 finally 中都释放
  - ✅ 正确：只在 finally 中释放

## 四、异常处理规范

### 4.1 统一异常处理

- [ ] **使用 `ExHandler.Run` 或 `ExHandler.Run<T>`**

  - ✅ 正确：
    ```csharp
    ExHandler.Run(() =>
    {
        // 可能抛出异常的代码
    }, message: "操作描述");
    ```

- [ ] **使用 `ExHandler.SafeGet` 和 `ExHandler.SafeSet`**
  - ✅ 正确：用于简单的属性访问，静默处理异常
  - ❌ 错误：用于需要详细日志的复杂操作

### 4.2 异常信息

- [ ] **异常必须包含上下文信息**

  - ✅ 正确：`ExHandler.Run(..., message: "FormatTables: 处理表格时出错");`
  - ❌ 错误：`ExHandler.Run(..., message: "出错");`

- [ ] **异常日志必须包含调用者信息**
  - ✅ 正确：`ExHandler` 自动包含调用者文件和方法信息

## 五、依赖注入规范

### 5.1 服务注册

- [ ] **所有服务必须在 `ServiceCollectionExtensions` 中注册**

  - ✅ 正确：在 `RegisterPPAServices` 方法中注册
  - ❌ 错误：在业务代码中直接 `new` 服务实例

- [ ] **服务生命周期**
  - ✅ `Singleton`：配置、日志提供者等全局单例
  - ✅ `Transient`：业务服务、Helper 类等
  - ✅ `Scoped`：根据实际需求使用

### 5.2 构造函数注入

- [ ] **优先使用构造函数注入**

  - ✅ 正确：`internal class TableBatchHelper(ITableFormatHelper helper, ILogger logger)`
  - ❌ 错误：在方法中通过 `ServiceProvider` 解析

- [ ] **禁止直接访问 `Globals.ThisAddIn`**
  - ❌ 错误：`var service = Globals.ThisAddIn.GetService<IService>();`
  - ✅ 正确：通过构造函数注入

## 六、格式化操作规范

### 6.1 选区验证

- [ ] **统一使用 `ShapeHelper.ValidateSelection`**

  - ✅ 正确：在批量操作开始时验证选区
  - ✅ 正确：处理 null 返回值，显示用户提示

- [ ] **选区刷新策略**
  - ✅ 正确：使用 `GetSelectionWithRetry` 方法，支持自动刷新 Application 后重试

### 6.2 Undo 支持

- [ ] **所有格式化操作必须支持 Undo**
  - ✅ 正确：在操作开始时调用 `UndoHelper.BeginUndoEntry`
  - ✅ 正确：在验证选区成功后调用，避免无效的 Undo 条目

### 6.3 用户反馈

- [ ] **必须通过 `Toast` 提供用户反馈**
  - ✅ 正确：成功、警告、错误情况都要显示 Toast
  - ❌ 错误：静默失败，不提示用户

## 七、代码质量规范

### 7.1 命名规范

- [ ] **NetOffice 对象使用 `NETOP` 别名**

  - ✅ 正确：`using NETOP = NetOffice.PowerPointApi;`
  - ✅ 正确：`NETOP.Application`、`NETOP.Shape`

- [ ] **Application 变量命名**
  - ✅ `netApp`：NetOffice Application 对象
  - ✅ `nativeApp`：Native COM Application 对象
  - ✅ `abstractApp`：抽象接口 Application 对象

### 7.2 空值检查

- [ ] **所有 COM 对象访问前必须检查 null**

  - ✅ 正确：`if (shape == null) return;`
  - ✅ 正确：使用 `ExHandler.SafeGet` 安全获取

- [ ] **使用空值合并运算符**
  - ✅ 正确：`var app = ApplicationHelper.GetNetOfficeApplication() ?? throw new InvalidOperationException();`

### 7.3 性能优化

- [ ] **避免重复获取 Application 对象**

  - ✅ 正确：在方法开始时获取一次，后续复用
  - ❌ 错误：在循环中重复获取

- [ ] **批量操作优先**
  - ✅ 正确：收集所有对象后批量处理
  - ✅ 正确：使用 `ApplyStyle` 等批量 API

## 八、文档和注释

### 8.1 XML 文档注释

- [ ] **所有公共方法必须有 XML 文档注释**

  - ✅ 正确：
    ```csharp
    /// <summary>
    /// 格式化表格
    /// </summary>
    /// <param name="tbl">要格式化的表格对象</param>
    public void FormatTables(NETOP.Table tbl)
    ```

- [ ] **复杂逻辑必须有注释说明**
  - ✅ 正确：说明为什么需要刷新 Application、为什么使用特定 API

### 8.2 代码审查标记

- [ ] **TODO 和 FIXME 标记**
  - ✅ 正确：使用 `// TODO: 说明` 标记待办事项
  - ✅ 正确：使用 `// FIXME: 说明` 标记需要修复的问题

## 九、自动化检查

### 9.1 静态分析

- [ ] **运行代码分析工具**
  - ✅ 使用 Visual Studio 代码分析
  - ✅ 检查未释放的 `IDisposable` 对象

### 9.2 扫描脚本

- [ ] **运行 `GetNativeComApplication` 扫描**

  - ✅ 检查是否有未受 Guard 保护的 native COM 调用
  - ✅ 命令：`rg "GetNativeComApplication" --type cs`

- [ ] **检查 `Profiler.LogMessage` 调用**

  - ✅ 确保所有日志都使用 `ILogger`
  - ✅ 命令：`rg "Profiler\.LogMessage" --type cs`

- [ ] **检查 `Globals.ThisAddIn` 直接访问**
  - ✅ 确保所有访问都通过 `IApplicationProvider`
  - ✅ 命令：`rg "Globals\.ThisAddIn" --type cs`

### 9.3 手动检查清单

在提交代码前，手动检查以下项目：

- [ ] 所有 `NETOP.*` 对象是否在适当的时候释放？
- [ ] 循环中是否持有大量 COM 对象？
- [ ] 是否使用了 `ApplicationHelper` 获取 Application？
- [ ] 是否使用了 `ILogger` 而不是 `Profiler.LogMessage`？
- [ ] 异常处理是否包含足够的上下文信息？
- [ ] 是否支持 Undo 操作？
- [ ] 是否提供了用户反馈（Toast）？

## 十、常见错误模式

### 10.1 禁止的模式

- ❌ **直接访问 Globals**

  ```csharp
  var app = Globals.ThisAddIn.Application;
  ```

- ❌ **缓存 Application 对象**

  ```csharp
  private NETOP.Application _cachedApp;
  ```

- ❌ **循环中累积 COM 对象**

  ```csharp
  var shapes = new List<NETOP.Shape>();
  foreach(var shape in slide.Shapes)
  {
      shapes.Add(shape);  // 累积，未释放
  }
  // 方法结束后才释放
  ```

- ❌ **使用 Profiler.LogMessage**

  ```csharp
  Profiler.LogMessage("信息");
  ```

- ❌ **直接访问 UnderlyingObject**
  ```csharp
  var native = netApp.UnderlyingObject;
  ```

### 10.2 推荐的模式

- ✅ **通过 ApplicationHelper 获取**

  ```csharp
  var app = ApplicationHelper.GetNetOfficeApplication();
  app = ApplicationHelper.EnsureValidNetApplication(app);
  ```

- ✅ **使用 using 释放**

  ```csharp
  using(var slide = AdapterUtils.UnwrapSlide(abstractSlide))
  {
      using(var shapes = slide.Shapes)
      {
          foreach(var shape in shapes)
          {
              using(shape)
              {
                  ProcessShape(shape);
              }
          }
      }
  }
  ```

- ✅ **批量处理后统一释放**

  ```csharp
  var shapes = new List<NETOP.Shape>();
  try
  {
      // 收集和处理
  }
  finally
  {
      shapes.DisposeAll();
  }
  ```

- ✅ **使用 ILogger**
  ```csharp
  _logger.LogInformation($"操作启动，参数={param}");
  ```

## 十一、审查流程

### 11.1 提交前自检

1. 运行静态分析工具
2. 运行扫描脚本检查规范违反
3. 手动检查本清单的关键项目
4. 确保所有测试通过

### 11.2 代码审查重点

审查者应重点关注：

1. **COM 对象生命周期**：检查循环、异常处理中的释放
2. **Application 获取**：确保使用 `ApplicationHelper`
3. **日志记录**：确保使用 `ILogger` 且包含足够信息
4. **异常处理**：确保使用 `ExHandler` 且包含上下文
5. **依赖注入**：确保通过构造函数注入

### 11.3 定期审查

- **每周**：运行扫描脚本，检查新增的规范违反
- **每月**：全面审查关键模块的 COM 对象释放
- **每季度**：更新审查清单，添加新的最佳实践

## 十二、工具和脚本

### 12.1 扫描脚本示例

```powershell
# 检查 GetNativeComApplication 调用
rg "GetNativeComApplication" --type cs

# 检查 Profiler.LogMessage 调用
rg "Profiler\.LogMessage" --type cs

# 检查 Globals.ThisAddIn 直接访问
rg "Globals\.ThisAddIn" --type cs

# 检查未释放的 using 语句
rg "foreach.*NETOP\." --type cs | rg -v "using"
```

### 12.2 代码分析规则

在 `.editorconfig` 或项目设置中启用：

- `CA2000`: 在丢失作用域之前释放对象
- `CA1063`: 正确实现 IDisposable
- `CA1816`: 正确调用 GC.SuppressFinalize

## 附录：快速参考

### A. Application 获取快速参考

| 场景                        | 方法                                                | 示例                                                               |
| --------------------------- | --------------------------------------------------- | ------------------------------------------------------------------ |
| 获取 NetOffice Application  | `ApplicationHelper.GetNetOfficeApplication()`       | `var app = ApplicationHelper.GetNetOfficeApplication();`           |
| 确保 Application 有效       | `ApplicationHelper.EnsureValidNetApplication(app)`  | `app = ApplicationHelper.EnsureValidNetApplication(app);`          |
| 获取 Native COM Application | `ApplicationHelper.GetNativeComApplication(netApp)` | `var native = ApplicationHelper.GetNativeComApplication(netApp);`  |
| 获取抽象 Application        | `ApplicationHelper.GetAbstractApplication(netApp)`  | `var abstract = ApplicationHelper.GetAbstractApplication(netApp);` |

### B. COM 对象释放快速参考

| 场景           | 模式           | 示例                                        |
| -------------- | -------------- | ------------------------------------------- |
| 单个对象       | `using`        | `using(var shape = GetShape()) { }`         |
| 集合对象       | `using`        | `using(var shapes = slide.Shapes) { }`      |
| 循环中单个对象 | `using`        | `foreach(var s in shapes) { using(s) { } }` |
| 批量处理       | `DisposeAll()` | `shapes.DisposeAll();`                      |
| 异常安全       | `try-finally`  | `try { } finally { shapes.DisposeAll(); }`  |

### C. 日志记录快速参考

| 级别             | 使用场景     | 示例                                               |
| ---------------- | ------------ | -------------------------------------------------- |
| `LogDebug`       | 详细调试信息 | `_logger.LogDebug($"处理形状 {shape.Id}");`        |
| `LogInformation` | 关键操作流程 | `_logger.LogInformation($"FormatTables 启动");`    |
| `LogWarning`     | 警告信息     | `_logger.LogWarning("无法获取表格对象");`          |
| `LogError`       | 错误信息     | `_logger.LogError($"处理失败: {ex.Message}", ex);` |

---

**最后更新**：[当前日期]  
**维护者**：开发团队  
**审查周期**：每月
