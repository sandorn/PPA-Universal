# 实现方式整改方案

## 背景

- Bt401/Bt601 的根因是 `_shapeHelper` 仍依赖 `ApplicationHelper.GetNativeComApplication`，在 NetOffice Application 失效时访问 native RCW 导致异常。
- 现已通过 `ShapeBatchHelper` + `ShapeUtils` 完成第一轮整改：全面转向 NetOffice Application，**仅在必要场景刷新应用对象**，禁止在 `_shapeHelper` 内直接访问 native COM。
- 为避免类似问题再次出现，需要梳理项目中仍存在的“原生 COM 依赖”“ActiveWindow 校验缺失”“接口调用方式不统一”等隐患，并制定整体整改计划。

## 总体目标

1. **统一基础服务使用 NetOffice**：核心流程只依赖抽象接口 + NetOffice Application，native COM 仅在少数必要场景使用，并集中管理。
2. **入口层刷新 Application**：由业务入口（BatchHelper、Ribbon、CommandRouter）负责刷新/验证 Application；`ShapeUtils` 等底层工具不再接触 native COM。
3. **Undo / MSO / 原生命令**：为仍需 native COM 的场景提供可复用的“刷新 + 调用 + 降级”模板，避免把异常传播到业务层。

## 专项梳理

### 1. native COM 直接依赖

| 模块                                                      | 现状                                                                    | 隐患                                                        | 整改建议                                                                                                                                     |
| --------------------------------------------------------- | ----------------------------------------------------------------------- | ----------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| `ApplicationHelper.GetNativeComApplication`               | 执行时会遍历 ApplicationProvider / UnderlyingObject；对象失效时仍抛异常 | 任何调用该方法的业务都可能被 InvalidComObjectException 打断 | 保留方法，但统一在“NativeCom 调用适配层”内使用，避免业务直接调用                                                                             |
| `UndoHelper.BeginUndoEntry`                               | 先尝试 native App，再 fallback NetOffice                                | native App 已分离时仍频繁写日志，影响性能                   | 在进入 `BeginUndoEntry` 前刷新 Application；若仍拿不到，直接跳过 native 路径                                                                 |
| `CommandExecutor`（ExecuteCommandById / ExecuteMenuPath） | 强依赖 native `CommandBars`                                             | 大多数命令执行路径都会因 RCW 分离失败                       | 复用新的“NativeCommandScope” 包装：刷新 NetOffice Application → `CommandBars.ExecuteMso` 优先 → 只有在必须场景才用 `GetNativeComApplication` |
| `MSOICrop.CropShapesToSlide`                              | 内部直接使用 native App                                                 | 与 Bt401 相同风险                                           | 在调用前刷新 `NETOP.Application` 并在方法内部完全使用 NetOffice；若必须使用 native API，则添加防护                                           |

### 2. ActiveWindow / Selection 校验缺失

| 模块                                     | 现状                                           | 隐患                              | 整改建议                                                                                                                |
| ---------------------------------------- | ---------------------------------------------- | --------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `TableBatchHelper`, `ChartBatchHelper`   | 入口仍依赖 `netApp.ActiveWindow`，但未统一刷新 | `ActiveWindow == null` 时直接报错 | 复用 `ShapeBatchHelper` 的 `EnsureValidApplication` + `_shapeHelper` 重试逻辑，封装成 `BatchContextHelper`              |
| `CustomRibbon`, `KeyboardShortcutHelper` | 个别路径仍缓存旧 Application                   | UI 层可能再次传入失效 Application | Ribbon/快捷键在拿到 `_applicationProvider` 时始终通过 `ApplicationHelper.GetNetOfficeApplication()`，不缓存 native 对象 |

### 3. 日志/异常处理

| 模块                                                                  | 问题                                                               | 方案                                                                                                 |
| --------------------------------------------------------------------- | ------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------- |
| 多处日志出现重复 warn（e.g. GetNativeComApplication: 所有方法都失败） | 信息量大但难定位                                                   | 新增“Native 调用审计”logger，统一记录调用栈、是否 fallback 成功，避免业务日志被淹没                  |
| `ShapeUtils.ValidateSelection` Toast 打断流程                         | 业务层已经及时刷新 Application，但 `_shapeHelper` 仍弹出“无效选区” | 提供 `ValidateSelection(..., showWarningWhenInvalid:false)` 的标准用法：入口只在两次重试都失败时提示 |

## 分阶段实施

1. **第一阶段（当前已完成）**

   - `ShapeBatchHelper`/`ShapeUtils`：移除 native 依赖，完成。

2. **第二阶段（已完成）**

   - `TableBatchHelper` / `ChartBatchHelper`：复用 `ShapeBatchHelper` 的 Application 刷新模式。
   - `UndoHelper`：在外部刷新应用对象，内部只在 NetOffice 层调用 `StartNewUndoEntry`，减少 native 依赖。

3. **第三阶段（已完成）**

   - `CommandExecutor`: 引入 NetOffice 优先命令执行流，命令栏遍历、按钮查找均由 NetOffice 完成，移除 native 依赖。
   - `MSOICrop`: 形状收集/包裹使用 `AdapterUtils`，布尔运算通过 `ExecuteMso` 执行，结果定位与 Z-Order 恢复全在 NetOffice 层完成。
   - `ApplicationHelper`: 拆分 “NetChannel / NativeChannel”，所有入口统一走封装通道，native 获取与告警逻辑集中在 `NativeChannel`。

4. **第四阶段（治理 & 文档，进行中）**
   - 更新 `.cursor/rules/AGENTS.md`、`README.md` 的 COM 使用规范：
     1. 默认使用 NetOffice；
     2. 入口层统一刷新 Application；
     3. 访问 native 前必须明确调用 Guard/Scope；
     4. 全量建立 `GetNativeComApplication` 调用扫描。
   - 推出 `NativeComGuard` / `BatchContextHelper` 等治理组件的使用准则与检查清单。

## 后续工作

1. **实现 `BatchContextHelper`**：封装 Application 刷新、选区/幻灯片重试逻辑，供 Text/Table/Chart/Shape 批量入口复用。
2. **对 `UndoHelper`、`CommandExecutor`、`MSOICrop` 等模块增量改造**，用新的 Guard 模式替换直接的 native 调用。
3. **建立定期扫描**：通过简单脚本（`rg ApplicationHelper.GetNativeComApplication` 等）检查是否有新的 native 依赖流入。
4. **验证**：对 Bt401/Bt601、表格/文本/图表批量、快捷键、MSO 命令执行等路径进行冒烟测试，确保日志中不再出现反复的 `InvalidComObjectException`。

## NativeComGuard / BatchContextHelper 推广检查清单（草案）

1. **入口刷新**
   - 所有批量操作入口（Text/Table/Chart/Shape）调用 `BatchContextHelper.EnsureContext`。
   - Ribbon / 快捷键 / CommandExecutor 在执行前使用 `ApplicationHelper.EnsureValidNetApplication`。
2. **Guard 使用**
   - 访问 native COM 前必须显式调用 `NativeComGuard.Enter()`（或同等封装），退出时调用 `Dispose`。
   - Guard 内部统一记录调用方、重试次数、是否 fallback。
   - 禁止在 Guard 外调用 `ApplicationHelper.GetNativeComApplication`。
3. **日志与异常**
   - Guard 记录 `INFO`（调用成功）、`WARN`（fallback）、`ERROR`（彻底失败）。
   - BatchContextHelper 对 Selection / Slide 获取失败时，最多重试两次，并在最终失败时弹 Toast。
4. **代码审核项**
   - PR 中新增 native 调用时，必须附带 Guard 调用示例。
   - 代码评审 checklist 中新增条目：是否复用 BatchContextHelper / NativeComGuard。

## `GetNativeComApplication` 自动扫描脚本雏形

> 目标：每日 / 每次 CI 扫描代码库中新增的 native 访问入口，并输出报告。

### PowerShell（本地 / CI）

```powershell
$root = "D:\CODES\PPA"
$pattern = "ApplicationHelper\.GetNativeComApplication"
$ignore = @("docs\", "README", "抽象接口使用说明")
$results = Select-String -Path "$root\**\*.cs" -Pattern $pattern -CaseSensitive |
    Where-Object { $ignore -notcontains $_.Path }

if($results.Count -gt 0) {
    Write-Host "⚠ Detected native access points:"
    $results | ForEach-Object {
        Write-Host "$($_.Path):$($_.LineNumber) - $($_.Line.Trim())"
    }
    exit 1 # 让 CI 失败，提示检查
} else {
    Write-Host "✔ No new native access."
}
```

### Git Hook / CI 集成建议

- 在 `pre-push` 或 CI “lint” 阶段调用上述脚本。
- 扫描结果写入 `artifacts/native-scan.txt` 供回溯。
- 将白名单（允许存在的调用点）集中维护在 `tools/native-scan-whitelist.txt`，脚本读取并忽略。

该方案可作为 COM/NetOffice 实现方式整改的总纲。具体改造可按阶段执行，并在 `docs/项目全面评估报告.md` 中同步进度。

“分阶段实施”路线：① 已完成的 ShapeBatchHelper/ShapeUtils 整治；② 进行中的 Table/Chart Batch & UndoHelper；③ 计划中的 CommandExecutor、MSOICrop、ApplicationHelper 分层；④ 规则/文档治理。
附加“后续工作”列表，包括建设 BatchContextHelper、为 native 命令建立 Guard、定期扫描 GetNativeComApplication、冒烟验证核心按钮与快捷键。
